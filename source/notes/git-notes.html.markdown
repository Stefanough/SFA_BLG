---

title: Git
date: 2017-12-14 22:14 UTC
tags: 

---

# Git
Distributed version control. Basically a key value store where each key is a SHA-1 string (40 char hexadecimal 160 bit value) generated by Git's `git-hash` from the content and header of a Git object(plus parent SHA?) that points to a value (Gig object).

## Random

### Porcelain vs Plumbing
"Porcelain" refers to the collection of commands that make up the interface of Git. "Plumbing" refers to implementation details of Git and the collection of low-level commands used to investigate/interrogate it.

## File mode strings in git

## Integrity
Git checksums all files it is tracking on every operation. Git uses SHA-1, which outputs a 40 digit hexadecimal, to refer to all changes.

## Three Trees
The three main structures most commonly interacted with in Git.

### HEAD
`HEAD` is the pointer to the current branch reference. HEAD will be the parent of next commit. HEAD is the snapshot of the last commit on that branch.
- `git cat-file -p <ref>` - view contents and information of a Git object with a given reference. Pass `HEAD` as arg to see content for object that HEAD is pointing too. `-p` option pretty-prints objects content.
- `git ls-tree <ref>` - view file mode, git object type, and name for each file in the ref snapshot. Pass `HEAD` as argument to view files in the snapshot HEAD is pointing to. Regular files are of type `blob` and directories are of type `tree`. Pass `-r` flag to recurse into subtrees.

### index
Index is the proposed next commit. Essentially what is in the staging area. When a ref is checked out, Git populates the index with all the file contents in the working directory (working tree?). Those files are replaced with new versions when files are modified and staged and `git commit` converts the index into the tree for the new commit.
- `git ls-files -s --abbrev` - to show information about files in the index. Pass `-s` to show staged files contents. `--abbrev` for abbreviated SHAs.

### Working Directory
- AKA the **working tree**. The actual directory that contains project files for editing. Kind of like a sandbox for editing and trying out changes before they are added to the index (staged) or committed.

### workflow involving these three trees
- Typically inside an existing git project, a branch ref is checked out, HEAD is pointed to the most recent commit, the index is populated with the state of the data in that commit, and the project file and directory structure is recreated as the working tree. Changes to files in a git repo are initially made to the working directory (working tree), added to the index (staged) and committed in a new commit to which the HEAD is then pointed. The new commit can bee seen at the top of the log.
- The flow is different for new repositories created with `git init`, for example. HEAD will point to an empty master branch (empty because it contains no commits), the index will be empty because there is no recorded commits or state of the project to populate it, and the working tree will be empty or contain any untracked files. If the working tree has untracked files, or new files are created and then staged, they are added to the index. HEAD still doesn't point to any ref. IF staged the staged data is committed, the master branch has it's first commit and at that point, **HEAD**, **index**, and the **working tree** will all point at the same content.
  ```
  $ git status -s
  $

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git diff --cached
  $
  ```
  - At this stage, there are no modified or staged changes. HEAD and index are the same state.

  ```
  $ echo $'append me' >> tst_file_.txt
  
  $ git status -s
   M tst_file_1.txt


  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt
  ```
  - A new line has been appended to `tst_file_1.txt` and the change has not been staged. HEAD and index are still in identical state.

  ```
  $ git add tst_file_1.txt

  $ git status -s
  M  tst_file_1.txt

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 fb49f96 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git diff
  $

  $ git diff --cached
  diff --git a/tst_file_1.txt b/tst_file_1.txt
  index c6c82b2..fb49f96 100644
  --- a/tst_file_1.txt
  +++ b/tst_file_1.txt
  @@ -4,3 +4,4 @@ big
  entry 1
  entry 2
  entry 3
  +append me
  ```
  - The change has been staged. The updated reference SHA for `tst_file_1.txt` are visible in the contents of the index file as well as line 2 of the diff. This is a long-winded way of checking the difference between the commit pointed to by HEAD and the state of staging. If this change is committed, HEAD will point to a new commit and stage and HEAD will be at parity again.

## reset in Git
`git reset` moves what HEAD points to. `git checkout` changes HEAD itself, updates the index file with the new contents of HEAD and updates the working tree with the file structure and data of the project at that state. HEAD and index are in the same state. The work tree has unstaged changes from commit that HEAD previously pointed to. `git reset` defaults to the `--mixed` option when executed with out options, that is, if the `--mixed` option was passed in the above operation, the results would be the same.

Reset where HEAD points to. Can also set the state of index to match head with `--mixed` option and set the state of the working tree to match HEAD/index with `--hard` option.

`git reset` can take a commit SHA, a reference to HEADs current position, or a file path as arguments. When given a SHA, `reset` points HEAD at that commit and follows through with modifying the index and the working tree depending on the options given. The same behavior applies when given a relative HEAD position. `HEAD~` is synonymous with `HEAD~1` and points HEAD backwards one commit. `HEAD~2` moves back 2 commits, `HEAD~3` moves back 3 commits, etc.

When given a path (file or directory) `reset` will skip moving HEAD, set the state of index to that of HEAD. However, this change to index is scoped to the path given. `reset` with a path will only change data in index that is related to the given path. This behavior essentially results in unstaging changes to a file or files in a directory at the given path. `reset README.md` will unstage any staged changes made to that file but leave them in the working tree, returning it to an unstaged state.

- `git reset` manipulates the states of the _three trees_.
- When using `git reset` to point to a new reference:
  ```
  $ git log --oneline master
  5623dc1 (HEAD -> master) remove source file
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e    lib/tst_nested_file_1.txt
  100644 blob c6c82b2    tst_file_1.txt
  100644 blob e785eea    tst_file_2.txt
  100644 blob 7bde4e4    tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git status -s
  $

  ```
  - using `git reset eb307fc` will:
    - without args `git reset` defaults to the `--mixed` behavior.
    - point HEAD to the given reference
    - update the index to the state of that reference.
    - does not update the work tree. all changes that were present in the commit before the reset are now in the working tree and shown as unstaged when the status is viewed.
  ```
  $ git reset eb307fc

  $ git log --oneline master
  eb307fc (HEAD -> master) add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob efc0627   source/tst_source_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 efc0627 0      source/tst_source_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  ```

  - `git reset --soft` moves the head to the given ref but does not modify the index. In this case, moving the head back 1 commit changes the state of HEAD but index is not modified. It contains the data from the commit where HEAD was previously pointed that now shows up as staged because it differs from head. This essentially returns the project to the state right before `git commit` was executed. You can reset to the commit where HEAD previously pointed (`ea7140d`) which resets the state of HEAD and puts the project back to the same state before the first reset command.
  ```
  $ git log --oneline
  ea7140d (HEAD -> master) add source dir
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e    lib/tst_nested_file_1.txt
  100644 blob c6c82b2    tst_file_1.txt
  100644 blob e785eea    tst_file_2.txt
  100644 blob 7bde4e4    tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git reset --soft eb307fc

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob efc0627   source/tst_source_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git diff --cached
  diff --git a/source/tst_source_file_1.txt b/source/tst_source_file_1.txt
  deleted file mode 100644
  index efc0627..0000000
  --- a/source/tst_source_file_1.txt
  +++ /dev/null
  @@ -1 +0,0 @@
  -I'm in a source directory.
  ```

  - `git reset --hard` resets HEAD to the given pointer, sets the state of index to look like that of the new HEAD (nothing will be staged), sets the working tree to that of HEAD and index (changes structure/data of project files). This is potentially destructive.
  ```
  $ git log --oneline
  ea7140d (HEAD -> master) add source dir
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e    lib/tst_nested_file_1.txt
  100644 blob c6c82b2    tst_file_1.txt
  100644 blob e785eea    tst_file_2.txt
  100644 blob 7bde4e4    tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git reset --hard eb307fc

  $ git ls-tree -r --abbrev HEAD
  100644 blob 2906d6e   lib/tst_nested_file_1.txt
  100644 blob efc0627   source/tst_source_file_1.txt
  100644 blob c6c82b2   tst_file_1.txt
  100644 blob e785eea   tst_file_2.txt
  100644 blob 7bde4e4   tst_file_4.txt

  $ git ls-files -s --abbrev
  100644 2906d6e 0      lib/tst_nested_file_1.txt
  100644 efc0627 0      source/tst_source_file_1.txt
  100644 c6c82b2 0      tst_file_1.txt
  100644 e785eea 0      tst_file_2.txt
  100644 7bde4e4 0      tst_file_4.txt

  $ git status -s
  $
  ```

- `git reset` vs `git checkout`
  - `git reset` and `git checkout` both update the state of HEAD but `checkout` changes what branch HEAD points to while `reset` changes what commit the branch itself is pointing to. When `reset` is used, HEAD still points to the tip of the branch and that tip is pointed to the given ref. When `checkout` is used HEAD is "detached" from the tip and assumes the state of the given branch.
  ```
  (master)$ git log --oneline
  ea7140d (HEAD -> master) add source dir
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  (master)$ git reset --soft 81176ed

  (master)$ git log --oneline
  81176ed (HEAD -> master) Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  (master)$ git reset ea7140d

  (master)$ git checkout 81176ed
  Note: checking out '81176ed'.

  You are in 'detached HEAD' state...

  ((HEAD detached at 81176ed))$ git log --oneline master
  ea7140d (master) add source dir
  eb307fc add source dir
  81176ed (HEAD) Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  ((HEAD detached at 81176ed))$ git checkout ea7140d
  Previous HEAD position was 81176ed Add new lib.
  HEAD is now at ea7140d add source dir

  ((HEAD detached at 81176ed))$ git log --oneline master
  ea7140d (HEAD, master) add source dir
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit

  ((HEAD detached at 81176ed))$ git checkout master
  Switched to branch 'master'

  (master)$ git log --oneline
  ea7140d (HEAD -> master) add source dir
  eb307fc add source dir
  81176ed Add new lib.
  b512116 Introduce error.
  6360856 add tst_file_2.txt
  c1ec0f3 update files 1 and 4
  c16df89 initial commit
  ```
  - `git reset` points the branch to the new ref and maintains the branch relationship to HEAD. `git checkout` maintains the branches ref and changes what HEAD currently is.
  - Executing `checkout` with the SHA where the branches tip is pointed is different than executing with the branch name. This results in both HEAD and the branch tip pointing to the same SHA yet HEAD is not pointing to the branch. Executing `checkout` with the branches reestablishes the branch-HEAD relationship.
  - "checking out" a branch means pointing HEAD to the tip of a branch
  - `git checkout` also tries manipulate the data in the working tree safely while `git reset` can potentially destroy data in the working tree.
- Detached HEAD mode??

## amend
You can amend the current commit that HEAD is pointed to but it will change the SHA. Doesn't really change the existing commit as much as it replaces it with a new one and a new SHA.

## Git States

Three main states that data in a git repo can inhabit.
 - **modified** means that you have changed the file but have not committed it to you database yet
 - **staged** means that the file in its current state has been marked as ready for inclusion in the next commit snapshot. When working with Git commands **staged** and **cached** are synonymous.
 - **committed** means that the state of data is currently stored in the local database.

### git status
Show status of the working tree.

- `git status` - With no arguments, show **staged**, **modified** unstaged files, and untracked files in the working tree. Also includes instructions on how to add, stage, or checkout data.
- `git status -s` or `--short` gives the concise output. First collection of characters is two columns where each col contains a character giving the status of a staged, changed, modified staged, or untracked file. In general, the left col shows that a state of the file is has been staged and the right col show that there is unstaged data.

```
$ git status -s
MM tst_file_1.txt
 M tst_file_5.txt
A  tst_file_3.txt
M  tst_file_4.txt
AM tst_file_6.txt
 D tst_file_7.txt
?? tst_file_2.txt
```
| code | description                                                                                                                                                                                  |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ` M` | Right col `M` means there are unstaged changes to a file.                                                                                                                                    |
| `M ` | Left col `M` signifies changes to a tracked file have been staged.                                                                                                                           |
| `MM` | `M` in both cols when file has staged modifications as well as unstaged modifications. Reverts to a single `M` in the left col if the unstaged changes are added.                            |
| `A ` | `A` in left col when new, previously untracked file has been staged and is ready to be tracked.                                                                                              |
| `AM` | `A` in left col and `M` in right col when a untracked file has been added then modified but those modifications are unstaged. Reverts to single `A` in left col if those changes are staged. |
| ` D` | `D` in the right col indicates a file has been deleted and the changes (the deletion) have not been staged.                                                                                  |
| `D ` | `D` in the right col indicates a file has been deleted and the changes (the deletion) have not been staged.                                                                                  |
| `??` | Signifies untracked file                                                                                                                                                                     |
## Diffing
The command `git diff` without any args will show changes (additions and deletions) made to tracked files in the working tree against staging. It will not show any changes that are staged and are about to be committed as it does not diff against the previous commit.
 
- Add a line to a file
```
$ cat tst_file_2.txt
one
two
three
four

$ echo $'six' >> tst_file_2.txt
$ cat tst_file_2.txt
one
two
three
four
six
```

- View changes
```
$ git status -s
 M tst_file_2.txt
```

- View diff between unstaged and staged data
```
$ git diff
diff --git a/tst_file_2.txt b/tst_file_2.txt
index f384549..d172ff5 100644
--- a/tst_file_2.txt
+++ b/tst_file_2.txt
@@ -2,3 +2,4 @@ one
 two
 three
 four
+six
```

Here is how Git CLI outputs the diff of `tst_file_2.txt` after appending one line to the file. The line addition is prefixed with a `+`. Deletions would be prefixed with a `-`. Opening a text editor and changing the spelling (single character change) of an line 2 shows changes as whole line changes:
```
diff --git a/tst_file_2.txt b/tst_file_2.txt
index f384549..e785eea 100644
--- a/tst_file_2.txt
+++ b/tst_file_2.txt
@@ -1,4 +1,5 @@
 one
-two
+twwo
 three
 four
+six
```

- Pass the `--staged` or `--cached` flag to `git diff` to see changes made against the previous commit in the current branch. In its state above, `tst_file_2.txt` will not show any diff against the previous commit. `git add tst_file_2.txt` to stage the files changes:
```
git diff --staged
diff --git a/tst_file_2.txt b/tst_file_2.txt
index f384549..e785eea 100644
--- a/tst_file_2.txt
+++ b/tst_file_2.txt
@@ -1,4 +1,5 @@
 one
-two
+twwo
 three
 four
+six
```

## Git patches
Related to selectively changing files by using hunks.

## Git history/log
- `git log` with no args to view the full SHA, author, date, and message of each commit in current branch in reverse chronological order (most recent first). By default, the output is piped into the default terminal file pager utility (probably **les**). Pass `--no-pager` or `-P` before the `log` command to view log without pager.
- Pass `--abbrev-commit` option to view abbreviated commit SHAs. Shortened to seven characters by default.
- `-p` or `--patch` option to view changes between commits.
- `-P` or `--no-pager` option to view log without terminal file pager.

## Merging

### what happens during a merge operation

#### Simple Fast Forward
The most simple type of merge is a **fast-forward**. This takes place when the commit of the branch being merged in can be reached from the branch from the branch being merged into. In other words the tip of the current branch is a direct ancestor of the tip of the branch being merged in.
- On branch master.
- Make and checkout new branch "hotfix"
- Add 2 commits to hotfix. Now 2 commits ahead of master
  ```
  (hotfix) $ git log --oneline -n 4
  0a7e628 (HEAD -> hotfix) correct sequence
  684da96 correct error
  5e49610 (master) add source dir and linting tst_file_1.txt
  eb307fc add source dir
  ```
- checkout master branch and merge in hotfix
  ```
  (master) $ git merge hotfix
  Updating 5e49610..0a7e628
  Fast-forward
  tst_file_1.txt | 2 +-
  tst_file_2.txt | 2 +-
  2 files changed, 2 insertions(+), 2 deletions(-)

  (master) $ git log --oneline -n 4
  nymbp-sarmijo-2:~/git_test_playground(master):sarmijo $ glo -n 4
  0a7e628 (HEAD -> master, hotfix) correct sequence
  684da96 correct error
  5e49610 add source dir and linting tst_file_1.txt
  eb307fc add source dir
  ```
In the fast-forward merge, now extra commits are created. The ref for the tip of master is moved up (fast-forwarded) up to the tip of the hotfix branch. HEAD and the two branch tips point to the same commit. Hotfix can safely be deleted `git branch -d hotfix`.

#### three-way merge
This type of merge operation occurs when two branches share a common ancestor but the tip of one branch can't be reached by the other. In this situation, Git creates a new snapshot that results from this three way merge and automatically creates a new commit that points to it.
```
changes and their chronological order:

                   Common
                  Ancestor                          [master]
                      |                                |
(c 0) <-- (c 1) <-- (c 2) <-------------- (c 5) <--- (c 7)
                         \
                          \
                           (c 3) <-- (c 4) <-- (c 6)
                                                 |
                                             [feature]
```
In the Git CLI this can be even more brutally visualized:
```
(master) $ git log --pretty=format:"%h - %ad - %s" --all --graph -n 6
* 263015d - Apr 5 22:58:48 - spelling
* * 45671e8 - Apr 5 22:29:28 - correct context
* | * 30bebc1 - Apr 5 22:57:15 - yes mutate your data
* | * 79ec092 - Apr 5 22:28:41 - correct sequence
* | * c25f03c - Apr 5 22:27:43 - fix type
* |/
* * 5e49610 - Apr 5 15:48:16 - add source dir and linting tst_file_1.txt
```
Merge commits are special because they have more than one parent
```
                   Common                                   Merge commit
                  Ancestor                                    [master]
                      |                                          |
(c 0) <-- (c 1) <-- (c 2) <-------------- (c 5) <--- (c 7) <-- (c 8)
                         \                                    /
                          \                                  /
                           (c 3) <-- (c 4) <-- (c 6) <------
                                                 |
                                             [feature]

(master) $ git merge feature
Merge made by the 'recursive' strategy.
lib/tst_nested_file_1.txt | 1 +
tst_file_1.txt            | 2 +-
tst_file_2.txt            | 2 +-
3 files changed, 3 insertions(+), 2 deletions(-)

(master) $ git log --pretty=format:"%h - %ad - %s" -n 7
7ac3a9f - Apr 5 23:08:40 - Merge branch 'feature'
263015d - Apr 5 22:58:48 - spelling
30bebc1 - Apr 5 22:57:15 - yes mutate your data
45671e8 - Apr 5 22:29:28 - correct context
79ec092 - Apr 5 22:28:41 - correct sequence
c25f03c - Apr 5 22:27:43 - fix type
5e49610 - Apr 5 15:48:16 - add source dir and linting tst_file_1.txt

(master) $ git log --abbrev-commit -n 1
commit 7ac3a9f (HEAD -> master)
Merge: 263015d 30bebc1
Author: Stefan Armijo <stefan.armijo@gmail.com>
Date:   Sun Apr 5 23:08:40 2020 -0400

    Merge branch 'feature'
```
Last output shows the 2 parents of the merge commit. The `git log` shows how the commits from the tow branches are interleaved.


## Rebasing
With **Rebasing** you can take all the changes made in one branch and replay them on a different branch. With the above example:
  ```
  changes and their chronological order:
  
                     Common
                    Ancestor                          [master]
                        |                                |
  (c 0) <-- (c 1) <-- (c 2) <-------------- (c 5) <--- (c 7)
                           \
                            \
                             (c 3) <-- (c 4) <-- (c 6)
                                                   |
                                               [feature]
  
  (master) $ git log --pretty=format:"%h - %ad - %s" --all --graph -n 6
  * 263015d - Apr 5 22:58:48 - spelling
  * * 45671e8 - Apr 5 22:29:28 - correct context
  * | * 30bebc1 - Apr 5 22:57:15 - yes mutate your data
  * | * 79ec092 - Apr 5 22:28:41 - correct sequence
  * | * c25f03c - Apr 5 22:27:43 - fix type
  * |/
  * * 5e49610 - Apr 5 15:48:16 - add source dir and linting tst_file_1.txt
  ```

What happens during a rebase operation?

- Checkout `feature` branch and rebase it onto `master` branch
- Get the diff introduced by each commit of the branch you're on (`feature`).
- Save each of those diffs to temp files.
- `reset` the current branch `feature` branch to the same commit as `master`
- Apply each diff in turn.
  ```
  (feature) $ git rebase master
  First, rewinding head to replay your work on top of it...
  Applying: fix type
  Applying: correct sequence
  Using index info to reconstruct a base tree...
  M     tst_file_2.txt
  Falling back to patching base and 3-way merge...
  Auto-merging tst_file_2.txt
  Applying: yes mutate your data

  (feature) $ git log --pretty=format:"%h%d - %ad - %s" -n 6 --decorate
  3c47681 (HEAD -> feature) - 22:57:15 - yes mutate your data
  95057ba -                   22:28:41 - correct sequence
  457a597 -                   22:27:43 - fix type
  263015d (master) -          22:58:48 - spelling
  45671e8 -                   22:29:28 - correct context
  5e49610 -                   15:48:16 - add source dir and linting tst_file_1.txt
  ```
- `checkout` master and execute a fast-forward merge
  ```
  (master) $ git merge feature
  Updating 263015d..3c47681
  Fast-forward
  lib/tst_nested_file_1.txt | 1 +
  tst_file_1.txt            | 2 +-
  tst_file_2.txt            | 2 +-
  3 files changed, 3 insertions(+), 2 deletions(-)
  ```

### Interactive Rebasing
Pass `-i` to the rebase command to enter interactive rebase mode. Interactive rebase stops after each commit and allows for changing/modification of files, their contents, and/or their commit messages.

### Rebase vs Merge
One thing to notice about rebasing vs merging is the structure of the commits after the operation. After a three-way merge, commits will retain their chronological order, and the commits for the two branches may be interleaved. After a rebase operation, the commits for the branch that was rebased onto the target branch will be stacked on top of the tip of the target branch.

The final commit after a rebase or merge operation between two branches should be identical. Only the history will look different.

### When to use rebase vs merge
Rebasing generally looks cleaner than a 3-way merge as the new commits stack cleanly on top of the base branch. It looks like linear work even when the work has happened in parallel. Rebase is good for projects where you have less privilege and want to make merging your work easier.

## Squashing
What is squashing? Use `rebase` to bundle changes from multiple commits into a single commit.

## what is a git ref

## what is a git commit
A commit is a known state or snapshot of a project. When in a Git repository, the current commit determines the current state of files. A commit must always be "checked out".

### committing
- `git commit` with no args for interactive committing. Opens the default text editor and prompts for a commit message. Included is boilerplate that has been commented out. Saving and exiting will abort the commit as commented out lines are ignored and a message must be included. Add uncommented text, save, and commit to complete the commit transaction. Only uncommented lines will appear in the commit log.
- Pass `-v` option to include the diff of the change in the commit message.
- Pass `-m` option to include commit message inline `git commit -m 'Add moment.js.'`
- Pass `-a` to include all changed files, skipping the staging area.

## Tracking in Git
"Tracking" can refer to two activities in Git: Tracking of files in the repository so modifications, additions and deletions can be detected and commited, and the tracking branches against a remote repo.

## ref vs commit

## Patch
Actual changes made to source code. When viewing code changes in a git log with the `-p` option, the differences between commits (changes) are patches.

## staging area
A part of the Git repository that stores data about the changes that will be included in the next commit (snapshot) operation. Technically, it is a file in the Git directory that stores this information.

## Working with Remote Repositories 
Pushing, setting up, etc.

A Remote Repository is copy of a local repository that exists on a different host (on a remote machine).

### Upstream

### Remote tracking

### Fetch vs Pull









## Cheat Sheet/Recipes

**Go back one commit**

1. `$ git reset HEAD~`
   - This command moves the HEAD back one commit but leaves changes associated with that commit preserved on disk. This is equivalent to passing the `--mixed` tag which is the default behavior. If you want to revert the repository's state on disk back to the way it looked with the previous commit, pass the `--hard` flag with the command.
2. *do stuff to files*
3. `$ git add .`
   - Re-add all changes in tracked files.
4. `$ git commit -m '<message>'`
   - New commit message for the corrected commit.

**Untrack an already tracked file after modification**

`$ git rm  --cached <filename>`

**Undoing git rm**

1. `$ git reset`
2. `$ git checkout -- $(git ls-files -d)`

*git log* - view commit history

**Committing** - Committing is kind of like a meta-save. You're committing changes you've made to code to the branch you're working in. Like a snapshot of the current state of the code.

If I have a master branch and I make a checkout a new branch `styling_fix`. I make some changes and save those to the project files but I don't commit. The state of the code is still the "current state" from when made the new branch. If I switch back to `master` branch has the state of any of the branches changed? No. I can switch between branches and the files will remain unchanged.

If I go back into branch `styling_fix` and commit the changes, the state change has been recorded. I can switch back to master and see the project files in a different state.

`$ git branch -d <branch>` - Delete unwanted branch.

`$ git branch` - view available branches and current working branch.

`$ git commit -a -m "super important commit message"` - Stage modified files for commit (but not new files) and commit with one command.

`$ git help <command>` - help documentation for specific commands
`$ git remote -v show` - shows remote server names and URLs

**General Git Procedure**

`$ git commit -m "commitment message"`

`$ git add` is synonymous with `$ git stage`

**Gist vs Repository**

**Git Clone Procedure**

`$ git clone <repo>` - creates a new directory with the repository's name and pulls repo's contents.
`$ git clone <repo> <directory_name>` - Same as above but creates a new directory with the specified name.

**Git init Procedure**

`$ git init <name>` - creates a new directory with the `.git/` directory and its associated config files inside.

**Forking vs Cloning**
Forking creates a private copy of a repo with out tracking or permissions set up. Cloning creates a copy of a repo and sets up remote tracking for the repo the copy was cloned from.

**Git ignore**

* navigate to repository
* `$ touch .gitignore` to create a .gitignore file

Does this work retroactively? If I add a filetype to .gitignore will they be removed from the repo retroactively.

- create repo with .gitignore
- commit and push to server
- create several .txt files and .md files
- commit and push to server
- add `*.md` to .gitignore

*the .gitignore does not remove items retroactively. It only prevents items from being added or committed to the repository.*

Git workflow
------------
    * `git add`

Help in Windows: git help
                 git help "command"

Help in Linux: git --help
               git <command> --help

Navigation:
git rev-parse --show-toplevel     shows the top level (root) directory for the current repo

Hella Useful:
git ls-remote --get-url           shows the remote address where data will be pushed?
git push -u origin master         pushes current changes to remote server or address

| command                           | Description                                                                                                                |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| `git status`                      | Show status of working tree.                                                                                               |
| `git log`                         | Show commit history                                                                                                        |
| `git show`                        | Show various types of objects.                                                                                             |
| `git instaweb`                    | Instantly browse your working repository in gitweb.                                                                        |
| `git show-branch`                 | Show branches and their commits.                                                                                           |
| `git ls-tree`                     | List the contents of a tree object.                                                                                        |
| `git update-index`                | Register file contents in the working tree to the index.                                                                   |
| `git mktree`                      | Build a tree-object from ls-tree formatted text.                                                                           |
| `git checkout-index`              | Copy files from the index to the working tree.                                                                             |
| `git for-each-ref`                | Output information on each ref.                                                                                            |
| `git ls-files`                    | Show info about files in the index and the working tree.                                                                   |
| `git ls-remote`                   | List references in a remote repository.                                                                                    |
| `git rev-list`                    | Lists commit objects in reverse chronological order.                                                                       |
| `git config`                      | Get and set repository or global options.                                                                                  |
| `git checkout`                    | Checkout a branch or paths to the working tree.                                                                            |
| `git commit`                      | Record changes to the repository.                                                                                          |
| `git update-index`                | Register file contents in the working tree to the index.                                                                   |
| `git config --show-origin <key>`  | Show origin of a specific configuration key. For example, `git config --show-origin user.name`                             |
| `git config <key>`                | Show value of specific git config key. `git config user.name` => `Stefan Armijo`                                           |
| `git config --list --show-origin` | Show Git settings and where they which config file (`etc/gitconfig`, `~/.gitconfig`, `.git/config`) they are sourced from. |


 ENVIRONMENT VARIABLES:
| variable | description                                                                                                                                                                                                                              |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GIT_INDEX_FILE | This var allows the specification of an alternate index file. If not specified, the default of $GIT_DIR/index is used.                                                                                                             |
| GIT_DIR        | View with `git rev-parse --git-dir`. If the GIT_DIR environment variables set then it specifies a path to use instead of the default .git for the base of the repository. The --git-dir command-line option also sets this value. |
| GIT_WORK_TREE  | Set the path to the root of the working tree. This can also be controlled by the --work-tree command line option and the core.work tree configuration variable.                                                                    |

-------------------------------------------------------------
create a new repository on the command line:

echo "# death" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/Stefanough/death.git
git push -u origin master

-------------------------------------------------------------
push an existing repository from the command line:

Git remote add origin https://github.com/Stefanough/thing.git
git push -u origin master

-------------------------------------------------------------


```na
Anatomy of git command
git commit -m "message about commit here"
 |    |     |              |______________________________________
 |    |     |___________________________________                 |
 |    |___________________                     |                 |
 |                       |                     |                 |
initialize the    commiting changes    message option     describe changes
git command       to current branch                       in this commit.
```

What are the steps involved in the Git workflow?


make changes to local files (the tree)
make a commit locally to the tree object?
push that commit to the remote repository?

Advantages over just keeping your working files in Google drive?


Git -init : create new empty repo

**Add colleague** -
`$ git remote add <alias> <url>` - Adds an upstream remote called 'alias' at the URL.
`$ git pull <alias> master` - pulls from the master branch of the remote called 'alias'
